- Component classes should have lean render method
- In arrow function can use prentheses and will omit return statement
- Less class based components allows for easy to follow data flow, more predictable and manageable
- Class Based: state and props are properties of , instead of just recieving props as argument
- Class based component lifecyle: fire automatically at certain points in time in the application
	- No side-effects in constructor, cause re-renders and take performance hit
- Invoking super() will invoke constructor of component that is being extended  
- Using state will behind the scenes call constuctor and set values
- getSnapshot will return data that comes in componentDidUpdate
	- Save data before update and then access it after the update
- Did update is for checking if it has receieved new data
- Render after should component update, prop lifecycles are then all after the render; state lifecyles like did mount and did update are also after render
- 'use' lifecyle methods are for accessing lifecyle when in functonal component
	- useEffect - react hook for all lifecyle methods in the application. Function executes for every render cycle
		- Essentially a combination of did mount and did update
		- Array as second argument of data that should effect change, empty array will mean no dependencies so only runs the first time and never again
- Run will unmount to clean up things before component gets removed
	- Can return fn from useEffect to run after the main render cycle. No second argument to useEffect and this returned fn will alwyas run after first render
- shouldComponentupdate: compare next props/state to current to tell when to re-render
- Should always make new object because change listeners are using reference, so need new reference
- React.memo to memoize and only re-render fn components if input changes. If parent changes information then react will give back snapshot
	- Good for fn components that do not need to update with every change in parent component
- Memo or shouldComponentUpdate should only be used when parent can change with no effect at all
	- NOT use when parent updating means fn component updating as well
- PureComponent: implemeting shouldComponentUpdate with full props check to check for re-render
- React changing the DOM: Old Virtual DOM and Re-rendered Virtual DOM
	- Faster then actual render, and checks if anything changes, and then only changes parts that changed in real DOM
-  Can return array of adjacent elements, as long as each element has a key. Each is just the return or a React.CreateElement
	- Array is still just one object, the keys are just to allow react to efficiently update it
- Can make auxiliary component that just outputs the props children
	- Works because can only return one object from React.CreateElement, typical function requirement to only return one expression	
	- React.Fragment is built in component to just render children like an aux
- HOC
	- They add something extra to the component
	- Could just be wrapping component or it is a function that returns a functional component. Child component passed into main function and returned by functional component
	- If changing markup/jsx then using general wrapping, using wrap on export to change logic
	- Need to pass props dynamically, functional nested LOC just return the wrapped component, so props passed to it are the same that is passed to the component
		- Use spread operator to spread the props to the LOC
		- Importing wrapped class is just result of whatever the functional component returns
- setState() schedules a value change and re-render, not guaranteed to execute immediately. Not guaranteed to be latest value
	- setState() can take a fn that returns object for new state, and can refer to prev state in there, to guarantee correct
- PropTypes
	- Add property to component object to set a type with the prop, can also control what fn receives and should return
- Refs 
	- References to select an element, anon function where first argument is DOM element that ref is on. Can then be stored globally
	- Use createRef() to get a reference object, and then make the ref on the DOM equal to that reference instead of a function
	- useRef() hook for functional components, can caall fn's on ref in useEffect() because runs AFTER jsk has been renderned
- Context
	- State in multiple components without passing it around
	- Globally available javascript value, obj, array, etc.
	- HOC that wraps the components that need access to the component, takes 'value' that matches initial value actin as a prop
		- Anything inside wrapper can then acces the values passed into the 'value of the wrapping component
	- Context provider for where value being set, consumer for where value being used. Consumer returns function with argument for properties of context
		- Class Based: Static contextType set to context you want to consume, gives you access to 'this.context' value you can use wherever you want
		- Functional components:  Use useContext() hook and pass in context provider to give access to values